### ðŸ”¹ What is a Lock?

* A **Lock** is like a **gate** that can be **locked (acquire)** or **unlocked (release)**.
* If a thread tries to acquire a lock thatâ€™s already locked, it will **wait** until the lock is released.
* This is how we prevent threads from running at the wrong time or out of order.

---

### ðŸ”¹ How it works in `FooBar`

#### Initialization

```python
self.l1 = Lock()
self.l2 = Lock()
self.l2.acquire()
```

* `l1` starts **free**, so `foo()` can run first.
* `l2` is **locked**, so `bar()` is forced to wait.

---

#### foo()

```python
self.l1.acquire()   # waits until foo's turn
printFoo()          # prints "foo"
self.l2.release()   # unlocks l2 â†’ lets bar() run
```

#### bar()

```python
self.l2.acquire()   # waits until foo releases l2
printBar()          # prints "bar"
self.l1.release()   # unlocks l1 â†’ lets foo() run again
```

---

### ðŸ”¹ Flow (for n=2)

1. `foo` acquires `l1` â†’ prints `"foo"` â†’ releases `l2`.
2. `bar` acquires `l2` â†’ prints `"bar"` â†’ releases `l1`.
3. Cycle repeats until both have printed `n` times.

---

ðŸ‘‰ So **locks enforce alternation**:

* `foo â†’ bar â†’ foo â†’ bar â€¦`

